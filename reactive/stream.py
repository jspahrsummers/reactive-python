import sys
from types import TracebackType
from typing import (
    Any,
    AsyncGenerator,
    AsyncIterable,
    AsyncIterator,
    Awaitable,
    Generator,
    Generic,
    Iterable,
    List,
    Optional,
    Type,
    TypeVar,
)

T = TypeVar("T")
U = TypeVar("U")
V = TypeVar("V")
TIn = TypeVar("TIn", contravariant=True)
TOut = TypeVar("TOut", covariant=True)


class StreamGenerator(AsyncGenerator[Iterable[TOut], TIn], Generic[TOut, TIn]):
    """
    Represents an asynchronous generator which yields a stream of values each time it is resumed (represented as an iterable).

    The streams (iterables) are of indefinite length, so they may yield zero or any other number of values.
    """

    def __init__(self, agen: AsyncGenerator[Iterable[TOut], TIn]):
        """
        Wraps a regular asynchronous generator that generates a stream of values.
        """

        self._agen = agen
        super().__init__()

    def __aiter__(self) -> "StreamGenerator[TOut, TIn]":
        return self

    async def __anext__(self) -> Iterable[TOut]:
        return await self._agen.__anext__()

    async def asend(self, x: TIn) -> Iterable[TOut]:
        return await self._agen.asend(x)

    async def athrow(
        self,
        exc_type: Type[BaseException],
        exc_value: Optional[BaseException] = None,
        traceback: Optional[TracebackType] = None,
    ) -> Iterable[TOut]:
        return await self._agen.athrow(exc_type, exc_value, traceback)

    async def aclose(self) -> None:
        await self._agen.aclose()

    TOut2 = TypeVar("TOut2", covariant=True)

    def __or__(
        self, other: "StreamGenerator[TOut2, TOut]"
    ) -> "StreamGenerator[TOut2, TIn]":
        """
        Chains together two stream generators with a convenient pipelining syntax:

            composed_stream = input_stream | output_stream
        
        Each value in each stream yielded from the left generator is fed into the right generator, in order. Yields the streams generated by the right generator, in the same order.
        """

        if not isinstance(other, StreamGenerator):
            return NotImplemented

        return chain(self, other)

    def __le__(self, upstream: AsyncIterable[TIn]) -> AwaitableIterable[TOut]:
        """
        Connects the stream generator to a data source (represented as an asynchronous iterable), so the generator will run over the values it receives.

        This can be used in either direction, as long as the arrow points "into" the stream generator. For example:

            outputs = stream <= inputs
            outputs = inputs >= stream

        Returns each value of each iterable yielded by the generator, in order.
        """

        if not hasattr(upstream, "__aiter__"):
            return NotImplemented

        return connect(self, upstream)


def chain(
    gen1: AsyncGenerator[Iterable[U], T], gen2: AsyncGenerator[Iterable[V], U]
) -> "StreamGenerator[V, T]":
    """
    Chains together two generators of iterables.
    
    Each value in each iterable yielded from the left generator is fed into the right generator, in order. Yields the iterables generated by the right generator, in the same order.
    """

    async def _chain(
        gen1: AsyncGenerator[Iterable[U], T], gen2: AsyncGenerator[Iterable[V], U]
    ) -> AsyncGenerator[Iterable[V], T]:
        try:
            # TODO: Catch StopIteration/StopAsyncIteration?
            await gen1.__anext__()
            await gen2.__anext__()

            result: Iterable[V] = []

            async def _flatmap(u_values: Iterable[U]) -> List[V]:
                v_values = []
                for u in u_values:
                    # TODO: Catch StopIteration/StopAsyncIteration?
                    for v in await gen2.asend(u):
                        v_values.append(v)

                return v_values

            while True:
                try:
                    t = yield result
                except BaseException as err:
                    exc = sys.exc_info()

                    # TODO: Catch StopIteration/AsyncIteration, or rethrown GeneratorExit?
                    uit = await gen1.athrow(*exc)
                    if uit:
                        yield await _flatmap(uit)

                    # TODO: Catch StopIteration/AsyncIteration, or rethrown GeneratorExit?
                    vit = await gen2.athrow(*exc)
                    if vit:
                        yield vit

                    raise
                else:
                    # TODO: Catch StopIteration/StopAsyncIteration?
                    result = await _flatmap(await gen1.asend(t))
        finally:
            # TODO: Catch StopIteration?
            await gen1.aclose()
            # TODO: Catch StopIteration?
            await gen2.aclose()

    return StreamGenerator(_chain(gen1, gen2))


# TODO: Split this into something like first(), last(), completed()
class AwaitableIterable(Awaitable[TOut], AsyncIterable[TOut], Generic[TOut]):
    """
    Wraps a regular asynchronous iterable with support for `await` syntax.
    """

    def __init__(self, it: AsyncIterable[TOut]):
        self._it = it
        super().__init__()

    def __aiter__(self) -> AsyncIterator[TOut]:
        return self._it.__aiter__()

    def __await__(self) -> Generator[Any, None, TOut]:
        return self.__aiter__().__anext__().__await__()


def connect(
    gen: AsyncGenerator[Iterable[TOut], TIn], upstream: AsyncIterable[TIn]
) -> AwaitableIterable[TOut]:
    """
    Connects a generator of iterables to a data source (represented as an asynchronous iterable), so the generator will run over each of the input values.

    Returns each value of each iterable yielded by the generator, in order.
    """

    async def _connect(
        gen: AsyncGenerator[Iterable[TOut], TIn], upstream: AsyncIterable[TIn]
    ) -> AsyncIterable[TOut]:
        # TODO: Catch StopIteration/StopAsyncIteration?
        await gen.__anext__()

        try:
            async for t in upstream:
                # TODO: Catch StopIteration/StopAsyncIteration?
                for u in await gen.asend(t):
                    yield u
        except BaseException:
            # TODO: Catch StopIteration/StopAsyncIteration, or rethrown GeneratorExit?
            it = await gen.athrow(*sys.exc_info())
            if it:
                for u in it:
                    yield u

            raise
        else:
            # TODO: Catch StopIteration/AsyncIteration, or rethrown GeneratorExit?
            # TODO: Use a custom exception type? Yielding values after GeneratorExit is disallowed according to the docs
            it = await gen.athrow(GeneratorExit)
            if it:
                for u in it:
                    yield u
        finally:
            # TODO: Catch StopIteration?
            await gen.aclose()

    return AwaitableIterable(_connect(gen, upstream))
